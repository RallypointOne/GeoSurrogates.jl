---
title: "Neural Network Surrogates"
---

All neural network surrogates in GeoSurrogates.jl are based on **SIREN** (Sinusoidal Representation Networks), which use periodic sine activations to effectively capture high-frequency spatial patterns.

## ImplicitTerrain.MLP

Single SIREN multi-layer perceptron for scalar field approximation.

### Constructor

```julia
ImplicitTerrain.MLP(;
    in = 2,
    hidden = 256,
    out = 1,
    n_hidden = 3,
    ω0 = 30f0,
    ωh = 1f0,
    rng = Random.MersenneTwister(42),
    alg = Adam(0.0001f0)
)
```

**Arguments:**

- `in` - Input dimension (default: 2 for x, y)
- `hidden` - Hidden layer width (default: 256)
- `out` - Output dimension (default: 1)
- `n_hidden` - Number of hidden layers (default: 3)
- `ω0` - First layer frequency scaling (default: 30)
- `ωh` - Hidden layer frequency scaling (default: 1)
- `rng` - Random number generator
- `alg` - Optimizer (default: Adam)

### Methods

```julia
fit!(model, x::Matrix, y::Vector; steps=1, batchsize=nothing)
fit!(model, r::Raster; steps=1, batchsize=nothing)
predict(model, coords::Tuple)
predict(model, x::Matrix)
predict(model, r::Raster)
```

### Example

```julia
using GeoSurrogates

elev = normalize(Raster("elevation.tif"))

model = ImplicitTerrain.MLP(hidden=512, n_hidden=4)
fit!(model, elev; steps=2000)

predicted = predict(model, elev)
```

---

## ImplicitTerrain.Model

Cascaded SIREN model with surface and geometry components, trained progressively using a Gaussian pyramid.

### Constructor

```julia
ImplicitTerrain.Model()
```

Creates a model with two `MLP` networks:
- `surface` - Captures large-scale terrain features
- `geometry` - Captures fine details via residuals

### Methods

```julia
fit!(model, r::Raster; steps=1000, batchsize=nothing)
predict(model, coords::Tuple)
predict(model, x::Matrix)
predict(model, r::Raster)
```

### Training Process

1. Build 4-level Gaussian pyramid from input raster
2. Train surface model progressively (coarse to fine)
3. Compute residuals at full resolution
4. Train geometry model on residuals

### Example

```julia
using GeoSurrogates

elev = normalize(Raster("elevation.tif"))

model = ImplicitTerrain.Model()
fit!(model, elev; steps=1000)  # 1000 steps per pyramid level

# Final prediction combines surface + geometry
predicted = predict(model, elev)
error = elev .- predicted
```

---

## WindSurrogate.WindSIREN

SIREN network for 2D vector field (wind u, v components).

### Constructor

```julia
WindSurrogate.WindSIREN(;
    in = 2,
    hidden = 256,
    out = 2,
    n_hidden = 3,
    ω0 = 30f0,
    ωh = 1f0,
    rng = Random.MersenneTwister(42),
    alg = Adam(0.0001f0)
)
```

### Methods

```julia
fit!(model, u::Raster, v::Raster; steps=1)
fit!(model, uv::RasterStack; steps=1)  # Stack with :u and :v layers
fit!(model, x::Matrix, y::Matrix; steps=1)
predict(model, coords::Tuple)  # Returns (u, v) tuple
predict(model, r::Raster)      # Returns (u_raster, v_raster)
```

### Example

```julia
using GeoSurrogates, Rasters

# Load wind components
u = normalize(Raster("u_wind.tif"))
v = normalize(Raster("v_wind.tif"))

model = WindSurrogate.WindSIREN()
fit!(model, u, v; steps=1000)

# Predict on new grid
u_pred, v_pred = predict(model, template_raster)

# Or predict at single point
u_val, v_val = predict(model, (-105.5, 40.2))
```

---

## CategoricalSIREN.CatSIREN

SIREN network for categorical/classification tasks with softmax output.

### Constructors

```julia
# From number of classes
CategoricalSIREN.CatSIREN(n_classes::Int; kwargs...)

# From raster (auto-detects classes)
CategoricalSIREN.CatSIREN(r::Raster; kwargs...)
```

**Keyword Arguments:**

- `in = 2` - Input dimension
- `hidden = 256` - Hidden layer width
- `n_hidden = 3` - Number of hidden layers
- `ω0 = 30f0` - First layer frequency
- `ωh = 1f0` - Hidden layer frequency
- `rng` - Random number generator
- `alg = Adam(0.0001f0)` - Optimizer
- `classes = nothing` - Class labels (auto-detected from raster)

### Methods

```julia
fit!(model, r::Raster; steps=1)
fit!(model, x::Matrix, y::Matrix; steps=1)  # y is one-hot encoded

predict(model, coords::Tuple)   # Returns probability vector
predict(model, r::Raster)       # Returns Raster of probability Dicts

# Get most likely class
CategoricalSIREN.predict_class(model, coords::Tuple)
CategoricalSIREN.predict_class(model, r::Raster)
```

### Example

```julia
using GeoSurrogates, Rasters

veg = Raster("fuel_models.tif")

# Auto-detect classes from raster
model = CategoricalSIREN.CatSIREN(veg)

fit!(model, veg; steps=2000)

# Probability distributions
probs = predict(model, veg)
# Each cell contains Dict{class => probability}

# Most likely class per cell
classes = CategoricalSIREN.predict_class(model, veg)
```

---

## Architecture Notes

### SIREN Activation

All neural surrogates use sinusoidal activations:

```julia
f(x) = sin(ω * x)
```

The frequency parameter `ω` controls the network's ability to represent high-frequency content:
- Higher `ω0` (first layer) = faster initial frequency encoding
- `ωh` (hidden layers) typically set to 1

### Weight Initialization

SIREN networks require special initialization:
- **First layer**: Uniform in `[-1/in, 1/in]`
- **Hidden layers**: Uniform in `[-√(6/in), √(6/in)]`
- **Biases**: Zeros

This initialization is handled automatically by the constructors.
